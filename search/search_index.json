{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Framewise Meet Client","text":"<p>A Python client library for building interactive applications with the Framewise API.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the package using pip:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from framewise_meet_client.app import App\nfrom framewise_meet_client.models.messages import TranscriptMessage\n\n# Create an app instance with your API key\napp = App(api_key=\"your_api_key_here\")\n\n# Join a specific meeting\napp.join_meeting(meeting_id=\"your_meeting_id\")\n\n# Define an event handler for transcripts\n@app.on_transcript()\ndef handle_transcript(message: TranscriptMessage):\n    transcript = message.content.text\n    is_final = message.content.is_final\n    print(f\"Received: {transcript}\")\n\n# Run the app\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>API Reference: Detailed documentation of all modules and functions</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>app</li> <li>auth</li> <li>connection</li> <li>errors</li> <li>event_handler</li> <li>events<ul> <li>base_handler</li> <li>connection_rejected_handler</li> <li>custom_ui_handler</li> <li>exit_handler</li> <li>invoke_handler</li> <li>join_handler</li> <li>transcript_handler</li> </ul> </li> <li>logging_config</li> <li>messaging</li> <li>models<ul> <li>messages</li> </ul> </li> <li>runner</li> </ul>"},{"location":"reference/app/","title":"app","text":""},{"location":"reference/app/#framewise_meet_client.app","title":"<code>framewise_meet_client.app</code>","text":""},{"location":"reference/app/#framewise_meet_client.app.App","title":"<code>App</code>","text":"<p>WebSocket client app with decorator-based event handlers.</p> Source code in <code>framewise_meet_client/app.py</code> <pre><code>class App:\n    \"\"\"WebSocket client app with decorator-based event handlers.\"\"\"\n\n    _event_aliases = {\n        \"join\": JOIN_EVENT,\n        \"exit\": EXIT_EVENT,\n        \"transcript\": TRANSCRIPT_EVENT,\n        \"custom_ui_response\": CUSTOM_UI_EVENT,\n        \"custom_ui\": CUSTOM_UI_EVENT,\n        \"invoke\": INVOKE_EVENT,\n        \"connection_rejected\": CONNECTION_REJECTED_EVENT\n    }\n\n    _message_type_mapping = {\n        JOIN_EVENT: JoinMessage,\n        EXIT_EVENT: ExitMessage,\n        TRANSCRIPT_EVENT: TranscriptMessage,\n        CUSTOM_UI_EVENT: CustomUIElementMessage,\n        INVOKE_EVENT: TranscriptMessage,\n        CONNECTION_REJECTED_EVENT: ConnectionRejectedMessage\n    }\n\n    def __init__(self, api_key: Optional[str] = None, host: str = \"localhost\", port: int = 8000):\n        \"\"\"Initialize the app with connection details.\n\n        Args:\n            meeting_id: ID of the meeting to join\n            api_key: Optional API key for authentication\n            host: Server hostname\n            port: Server port\n        \"\"\"\n        self.meeting_id = None\n        self.host = host\n        self.port = port\n        self.api_key = api_key\n        self.auth_status = None\n        self.connection = None\n        self.event_dispatcher = EventDispatcher()\n        self.message_sender = None\n        self.running = False\n        self.loop = None\n        self._main_task = None\n\n\n    def join_meeting(self,meeting_id):\n        self.meeting_id = meeting_id\n        self.connection = WebSocketConnection(self.host, self.port, meeting_id, self.api_key)\n        self.message_sender = MessageSender(self.connection)\n\n        for name in dir(self.message_sender):\n            if not name.startswith('_') and callable(getattr(self.message_sender, name)):\n                logging.info(\"set {name} in {message_sender}\")\n                setattr(self, name, getattr(self.message_sender, name))\n\n\n    def on(self, event_type: str):\n        \"\"\"Decorator to register an event handler for a specific message type.\n\n        Resolves event aliases to standard event types.\n\n        Args:\n            event_type: Type of event to handle (e.g., \"transcript\", \"join\")\n                        Or a UI element type (e.g., \"mcq_question\", \"info_card\")\n\n        Returns:\n            Decorator function\n        \"\"\"\n\n        resolved_event_type = self._event_aliases.get(event_type, event_type)\n\n        if resolved_event_type != event_type:\n            logger.debug(f\"Resolved event alias '{event_type}' to standard event type '{resolved_event_type}'\")\n\n        def decorator(func):\n            if event_type not in self._event_aliases:\n                logger.debug(f\"Registering direct handler for UI element type: {event_type}\")\n                def wrapper(data):\n                    if \"parsed_message\" in data:\n                        return func(data[\"parsed_message\"])\n                    else:\n                        return func(data)\n\n                self.event_dispatcher.register_handler(event_type)(wrapper)\n                return func\n\n            logger.debug(f\"Registering handler for event type '{resolved_event_type}': {func.__name__}\")\n            return register_event_handler(self, resolved_event_type, func)\n\n        return decorator\n\n    def __getattr__(self, name):\n        \"\"\"Dynamically create event handler methods.\n\n        This allows methods like on_transcript, on_join, etc. to be generated dynamically.\n        \"\"\"\n        if name.startswith('on_'):\n            event_name = name[3:]\n\n            if event_name in self._event_aliases:\n                event_type_value = self._event_aliases[event_name]\n\n                def handler_method(func=None):\n                    return self._on_event(event_type_value, func, name)\n                return handler_method\n\n        raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n\n    def _on_event(self, event_type: Union[str, EventType], func: Callable[[BaseMessage], Any] = None, shorthand_name: str = None):\n        \"\"\"Helper function to reduce code duplication in event registration.\"\"\"\n        event_type_value = event_type.value if isinstance(event_type, EventType) else event_type\n        if func is None:\n            return self.on(event_type_value)\n        logger.debug(f\"Using {shorthand_name} shorthand for {func.__name__}\")\n        return self.on(event_type_value)(func)\n\n    def invoke(self, func: Callable[[TranscriptMessage], Any] = None):\n        \"\"\"Alias for on_invoke for convenience.\n\n        Args:\n            func: Function that takes a TranscriptMessage and processes the event\n        \"\"\"\n        return self.on_invoke(func)\n\n    def run(self, auto_reconnect: bool = True, reconnect_delay: int = 5, log_level: str = None) -&gt; None:\n        \"\"\"Run the application (blocking).\n\n        Args:\n            auto_reconnect: Whether to automatically reconnect on disconnect\n            reconnect_delay: Delay between reconnection attempts in seconds\n            log_level: Optional log level to set (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n        \"\"\"\n        if log_level:\n            numeric_level = getattr(logging, log_level.upper(), None)\n            if isinstance(numeric_level, int):\n                logging.getLogger().setLevel(numeric_level)\n                logger.info(f\"Log level set to {log_level.upper()}\")\n            else:\n                logger.warning(f\"Invalid log level: {log_level}\")\n\n        if self.api_key:\n            try:\n                logger.info(\"Authenticating API key...\")\n                self.auth_status = authenticate_api_key(self.api_key)\n                if not self.auth_status:\n                    logger.error(\"API key authentication failed\")\n                    raise AuthenticationError(\"API key authentication failed\")\n                logger.info(\"API key authentication successful\")\n            except Exception as e:\n                logger.error(f\"Authentication error: {str(e)}\")\n                raise AuthenticationError(f\"Authentication failed: {str(e)}\")\n        else:\n            logger.warning(\"No API key provided. Some features may be limited.\")\n\n        self._register_default_handlers()\n\n        from .runner import AppRunner\n\n        runner = AppRunner(\n            self.connection,\n            self.event_dispatcher,\n            auto_reconnect,\n            reconnect_delay\n        )\n        runner.run(self)\n\n    def _register_default_handlers(self):\n        \"\"\"Register default handlers for important system events if not already registered.\"\"\"\n        if CONNECTION_REJECTED_EVENT not in self.event_dispatcher.handlers:\n            @self.on_connection_rejected\n            def default_connection_rejected_handler(message: ConnectionRejectedMessage):\n                reason = message.content.reason\n                meeting_id = message.content.meeting_id\n                logger.error(f\"Connection rejected for meeting {meeting_id}: {reason}\")\n                self.running = False\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the application.\"\"\"\n        if not self.running:\n            return\n\n        self.running = False\n        logger.info(\"Application stopping...\")\n\n    def create_meeting(self, meeting_id: str, start_time=None, end_time=None):\n        \"\"\"Create a meeting with the given parameters.\n\n        Args:\n            meeting_id: Unique identifier for the meeting\n            start_time: Start time of the meeting as datetime object (defaults to current time)\n            end_time: End time of the meeting as datetime object (defaults to 1 hour from start)\n        \"\"\"\n\n        if not self.api_key:\n            raise AuthenticationError(\"API key is required to create a meeting\")\n\n        if start_time is None:\n            start_time = datetime.datetime.utcnow()\n\n        if end_time is None:\n            end_time = start_time + datetime.timedelta(hours=1000)\n\n        start_time_utc = start_time.isoformat() + 'Z'\n        end_time_utc = end_time.isoformat() + 'Z'\n\n        url = 'https://backend.framewise.ai/api/py/setup-meeting'\n        headers = {\n            'accept': 'application/json',\n            'Content-Type': 'application/json'\n        }\n        payload = {\n            'meeting_id': meeting_id,\n            'api_key': self.api_key,\n            'start_time_utc': start_time_utc,\n            'end_time_utc': end_time_utc\n        }\n\n        response = requests.post(url, headers=headers, json=payload)\n        response.raise_for_status()\n\n        meeting_data = response.json()\n\n        logger.info(f\"Meeting created with ID: {meeting_id}\")\n        return meeting_data\n\n\n    def on_ui_type(self, ui_type: str):\n        \"\"\"Register a handler for a specific UI element type.\n\n        Args:\n            ui_type: UI element type to handle (e.g., 'mcq_question', 'info_card')\n\n        Returns:\n            Decorator function\n        \"\"\"\n        logger.debug(f\"Creating handler for UI element type: {ui_type}\")\n        return self.on(ui_type)\n\n    def on_connection_rejected(self, func: Callable[[ConnectionRejectedMessage], Any] = None):\n        \"\"\"Register a handler for connection rejection events.\n\n        Args:\n            func: Function that takes a ConnectionRejectedMessage and processes it\n        \"\"\"\n        return self._on_event(EventType.CONNECTION_REJECTED, func, \"on_connection_rejected\")\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.__init__","title":"<code>__init__(api_key=None, host='localhost', port=8000)</code>","text":"<p>Initialize the app with connection details.</p> <p>Parameters:</p> Name Type Description Default <code>meeting_id</code> <p>ID of the meeting to join</p> required <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for authentication</p> <code>None</code> <code>host</code> <code>str</code> <p>Server hostname</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Server port</p> <code>8000</code> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def __init__(self, api_key: Optional[str] = None, host: str = \"localhost\", port: int = 8000):\n    \"\"\"Initialize the app with connection details.\n\n    Args:\n        meeting_id: ID of the meeting to join\n        api_key: Optional API key for authentication\n        host: Server hostname\n        port: Server port\n    \"\"\"\n    self.meeting_id = None\n    self.host = host\n    self.port = port\n    self.api_key = api_key\n    self.auth_status = None\n    self.connection = None\n    self.event_dispatcher = EventDispatcher()\n    self.message_sender = None\n    self.running = False\n    self.loop = None\n    self._main_task = None\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.on","title":"<code>on(event_type)</code>","text":"<p>Decorator to register an event handler for a specific message type.</p> <p>Resolves event aliases to standard event types.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event to handle (e.g., \"transcript\", \"join\")         Or a UI element type (e.g., \"mcq_question\", \"info_card\")</p> required <p>Returns:</p> Type Description <p>Decorator function</p> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def on(self, event_type: str):\n    \"\"\"Decorator to register an event handler for a specific message type.\n\n    Resolves event aliases to standard event types.\n\n    Args:\n        event_type: Type of event to handle (e.g., \"transcript\", \"join\")\n                    Or a UI element type (e.g., \"mcq_question\", \"info_card\")\n\n    Returns:\n        Decorator function\n    \"\"\"\n\n    resolved_event_type = self._event_aliases.get(event_type, event_type)\n\n    if resolved_event_type != event_type:\n        logger.debug(f\"Resolved event alias '{event_type}' to standard event type '{resolved_event_type}'\")\n\n    def decorator(func):\n        if event_type not in self._event_aliases:\n            logger.debug(f\"Registering direct handler for UI element type: {event_type}\")\n            def wrapper(data):\n                if \"parsed_message\" in data:\n                    return func(data[\"parsed_message\"])\n                else:\n                    return func(data)\n\n            self.event_dispatcher.register_handler(event_type)(wrapper)\n            return func\n\n        logger.debug(f\"Registering handler for event type '{resolved_event_type}': {func.__name__}\")\n        return register_event_handler(self, resolved_event_type, func)\n\n    return decorator\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Dynamically create event handler methods.</p> <p>This allows methods like on_transcript, on_join, etc. to be generated dynamically.</p> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Dynamically create event handler methods.\n\n    This allows methods like on_transcript, on_join, etc. to be generated dynamically.\n    \"\"\"\n    if name.startswith('on_'):\n        event_name = name[3:]\n\n        if event_name in self._event_aliases:\n            event_type_value = self._event_aliases[event_name]\n\n            def handler_method(func=None):\n                return self._on_event(event_type_value, func, name)\n            return handler_method\n\n    raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.invoke","title":"<code>invoke(func=None)</code>","text":"<p>Alias for on_invoke for convenience.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[TranscriptMessage], Any]</code> <p>Function that takes a TranscriptMessage and processes the event</p> <code>None</code> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def invoke(self, func: Callable[[TranscriptMessage], Any] = None):\n    \"\"\"Alias for on_invoke for convenience.\n\n    Args:\n        func: Function that takes a TranscriptMessage and processes the event\n    \"\"\"\n    return self.on_invoke(func)\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.run","title":"<code>run(auto_reconnect=True, reconnect_delay=5, log_level=None)</code>","text":"<p>Run the application (blocking).</p> <p>Parameters:</p> Name Type Description Default <code>auto_reconnect</code> <code>bool</code> <p>Whether to automatically reconnect on disconnect</p> <code>True</code> <code>reconnect_delay</code> <code>int</code> <p>Delay between reconnection attempts in seconds</p> <code>5</code> <code>log_level</code> <code>str</code> <p>Optional log level to set (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>None</code> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def run(self, auto_reconnect: bool = True, reconnect_delay: int = 5, log_level: str = None) -&gt; None:\n    \"\"\"Run the application (blocking).\n\n    Args:\n        auto_reconnect: Whether to automatically reconnect on disconnect\n        reconnect_delay: Delay between reconnection attempts in seconds\n        log_level: Optional log level to set (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n    \"\"\"\n    if log_level:\n        numeric_level = getattr(logging, log_level.upper(), None)\n        if isinstance(numeric_level, int):\n            logging.getLogger().setLevel(numeric_level)\n            logger.info(f\"Log level set to {log_level.upper()}\")\n        else:\n            logger.warning(f\"Invalid log level: {log_level}\")\n\n    if self.api_key:\n        try:\n            logger.info(\"Authenticating API key...\")\n            self.auth_status = authenticate_api_key(self.api_key)\n            if not self.auth_status:\n                logger.error(\"API key authentication failed\")\n                raise AuthenticationError(\"API key authentication failed\")\n            logger.info(\"API key authentication successful\")\n        except Exception as e:\n            logger.error(f\"Authentication error: {str(e)}\")\n            raise AuthenticationError(f\"Authentication failed: {str(e)}\")\n    else:\n        logger.warning(\"No API key provided. Some features may be limited.\")\n\n    self._register_default_handlers()\n\n    from .runner import AppRunner\n\n    runner = AppRunner(\n        self.connection,\n        self.event_dispatcher,\n        auto_reconnect,\n        reconnect_delay\n    )\n    runner.run(self)\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.stop","title":"<code>stop()</code>","text":"<p>Stop the application.</p> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the application.\"\"\"\n    if not self.running:\n        return\n\n    self.running = False\n    logger.info(\"Application stopping...\")\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.create_meeting","title":"<code>create_meeting(meeting_id, start_time=None, end_time=None)</code>","text":"<p>Create a meeting with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>meeting_id</code> <code>str</code> <p>Unique identifier for the meeting</p> required <code>start_time</code> <p>Start time of the meeting as datetime object (defaults to current time)</p> <code>None</code> <code>end_time</code> <p>End time of the meeting as datetime object (defaults to 1 hour from start)</p> <code>None</code> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def create_meeting(self, meeting_id: str, start_time=None, end_time=None):\n    \"\"\"Create a meeting with the given parameters.\n\n    Args:\n        meeting_id: Unique identifier for the meeting\n        start_time: Start time of the meeting as datetime object (defaults to current time)\n        end_time: End time of the meeting as datetime object (defaults to 1 hour from start)\n    \"\"\"\n\n    if not self.api_key:\n        raise AuthenticationError(\"API key is required to create a meeting\")\n\n    if start_time is None:\n        start_time = datetime.datetime.utcnow()\n\n    if end_time is None:\n        end_time = start_time + datetime.timedelta(hours=1000)\n\n    start_time_utc = start_time.isoformat() + 'Z'\n    end_time_utc = end_time.isoformat() + 'Z'\n\n    url = 'https://backend.framewise.ai/api/py/setup-meeting'\n    headers = {\n        'accept': 'application/json',\n        'Content-Type': 'application/json'\n    }\n    payload = {\n        'meeting_id': meeting_id,\n        'api_key': self.api_key,\n        'start_time_utc': start_time_utc,\n        'end_time_utc': end_time_utc\n    }\n\n    response = requests.post(url, headers=headers, json=payload)\n    response.raise_for_status()\n\n    meeting_data = response.json()\n\n    logger.info(f\"Meeting created with ID: {meeting_id}\")\n    return meeting_data\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.on_ui_type","title":"<code>on_ui_type(ui_type)</code>","text":"<p>Register a handler for a specific UI element type.</p> <p>Parameters:</p> Name Type Description Default <code>ui_type</code> <code>str</code> <p>UI element type to handle (e.g., 'mcq_question', 'info_card')</p> required <p>Returns:</p> Type Description <p>Decorator function</p> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def on_ui_type(self, ui_type: str):\n    \"\"\"Register a handler for a specific UI element type.\n\n    Args:\n        ui_type: UI element type to handle (e.g., 'mcq_question', 'info_card')\n\n    Returns:\n        Decorator function\n    \"\"\"\n    logger.debug(f\"Creating handler for UI element type: {ui_type}\")\n    return self.on(ui_type)\n</code></pre>"},{"location":"reference/app/#framewise_meet_client.app.App.on_connection_rejected","title":"<code>on_connection_rejected(func=None)</code>","text":"<p>Register a handler for connection rejection events.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ConnectionRejectedMessage], Any]</code> <p>Function that takes a ConnectionRejectedMessage and processes it</p> <code>None</code> Source code in <code>framewise_meet_client/app.py</code> <pre><code>def on_connection_rejected(self, func: Callable[[ConnectionRejectedMessage], Any] = None):\n    \"\"\"Register a handler for connection rejection events.\n\n    Args:\n        func: Function that takes a ConnectionRejectedMessage and processes it\n    \"\"\"\n    return self._on_event(EventType.CONNECTION_REJECTED, func, \"on_connection_rejected\")\n</code></pre>"},{"location":"reference/auth/","title":"auth","text":""},{"location":"reference/auth/#framewise_meet_client.auth","title":"<code>framewise_meet_client.auth</code>","text":""},{"location":"reference/auth/#framewise_meet_client.auth.authenticate_api_key","title":"<code>authenticate_api_key(api_key)</code>","text":"<p>Authenticate an API key.</p> <p>This implementation validates the API key against a remote server.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The API key to authenticate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if authentication succeeded, False otherwise</p> Source code in <code>framewise_meet_client/auth.py</code> <pre><code>def authenticate_api_key(api_key: str) -&gt; bool:\n    \"\"\"Authenticate an API key.\n\n    This implementation validates the API key against a remote server.\n\n    Args:\n        api_key: The API key to authenticate\n\n    Returns:\n        True if authentication succeeded, False otherwise\n    \"\"\"\n    if not api_key:\n        logger.warning(\"Empty API key provided\")\n        return False\n\n    logger.debug(\"Authenticating API key...\")\n\n    url = 'https://backend.framewise.ai/api/py/validate-api-key'\n    headers = {\n        'accept': 'application/json',\n        'Content-Type': 'application/json'\n    }\n    data = {\n        'api_key': api_key\n    }\n\n    try:\n        response = requests.post(url, headers=headers, json=data)\n        response.raise_for_status()\n        result = response.json()\n        return result.get('is_valid', False)\n    except requests.RequestException as e:\n        logger.error(f\"Error during API key authentication: {e}\")\n        return False\n</code></pre>"},{"location":"reference/connection/","title":"connection","text":""},{"location":"reference/connection/#framewise_meet_client.connection","title":"<code>framewise_meet_client.connection</code>","text":""},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection","title":"<code>WebSocketConnection</code>","text":"<p>Manages WebSocket connection to the server.</p> Source code in <code>framewise_meet_client/connection.py</code> <pre><code>class WebSocketConnection:\n    \"\"\"Manages WebSocket connection to the server.\"\"\"\n\n    def __init__(self, host: str, port: int, meeting_id: str, api_key: Optional[str] = None):\n        \"\"\"Initialize the connection.\n\n        Args:\n            host: Server hostname\n            port: Server port\n            meeting_id: ID of the meeting to join\n            api_key: Optional API key for authentication\n        \"\"\"\n        self.host = host\n        self.port = port\n        self.meeting_id = meeting_id\n        self.api_key = api_key\n        self.websocket = None\n        self.connected = False\n\n    async def connect(self) -&gt; None:\n        \"\"\"Connect to the WebSocket server.\"\"\"\n        url = f\"ws://{self.host}:{self.port}/listen/{self.meeting_id}\"\n\n        # Add API key to headers if provided\n        headers = {}\n        if self.api_key:\n            headers[\"Authorization\"] = f\"Bearer {self.api_key}\"\n            logger.debug(\"Added API key to connection headers\")\n\n        try:\n            self.websocket = await websockets.connect(url)\n            self.connected = True\n            logger.info(f\"Connected to server at {url}\")\n\n            # Wait for auth confirmation if API key was provided\n            if self.api_key:\n                try:\n                    # Wait for auth confirmation message with timeout\n                    auth_message = await asyncio.wait_for(self.websocket.recv(), timeout=5.0)\n                    auth_data = json.loads(auth_message)\n\n                    if auth_data.get(\"type\") == \"auth_result\" and not auth_data.get(\"success\", False):\n                        logger.error(\"Authentication rejected by server\")\n                        await self.disconnect()\n                        raise AuthenticationError(\"Authentication rejected by server\")\n\n                    logger.info(\"Server authenticated connection\")\n\n                except asyncio.TimeoutError:\n                    # If we don't get an explicit auth confirmation, assume it's OK\n                    logger.warning(\"No explicit authentication confirmation from server\")\n\n\n        except Exception as e:\n            self.connected = False\n            logger.error(f\"Failed to connect: {str(e)}\")\n            raise ConnectionError(f\"Failed to connect: {str(e)}\")\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the WebSocket server.\"\"\"\n        if self.websocket and self.connected:\n            await self.websocket.close()\n            self.connected = False\n            logger.info(\"Disconnected from server\")\n\n    async def send(self, message: Dict[str, Any]) -&gt; None:\n        \"\"\"Send a message to the server.\n\n        Args:\n            message: JSON-serializable message to send\n        \"\"\"\n        if not self.connected or not self.websocket:\n            raise ConnectionError(\"Not connected to server\")\n\n        try:\n            await self.websocket.send(json.dumps(message))\n        except Exception as e:\n            logger.error(f\"Failed to send message: {str(e)}\")\n            raise ConnectionError(f\"Failed to send message: {str(e)}\")\n\n\n    async def send_json(self,message):\n        \"\"\"Send a JSON serializable message to the server.\n\n        Args:\n            message: JSON-serializable message to send\n        \"\"\"\n        # This is an alias for the send method\n        return await self.send(message)\n\n    async def receive(self) -&gt; Dict[str, Any]:\n        \"\"\"Receive a message from the server.\n\n        Returns:\n            Parsed JSON message from the server\n        \"\"\"\n        if not self.connected or not self.websocket:\n            raise ConnectionError(\"Not connected to server\")\n\n        try:\n            message = await self.websocket.recv()\n            return json.loads(message)\n        except websockets.exceptions.ConnectionClosed:\n            self.connected = False\n            logger.warning(\"Connection closed\")\n            raise ConnectionError(\"Connection closed\")\n        except Exception as e:\n            logger.error(f\"Failed to receive message: {str(e)}\")\n            raise ConnectionError(f\"Failed to receive message: {str(e)}\")\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.__init__","title":"<code>__init__(host, port, meeting_id, api_key=None)</code>","text":"<p>Initialize the connection.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname</p> required <code>port</code> <code>int</code> <p>Server port</p> required <code>meeting_id</code> <code>str</code> <p>ID of the meeting to join</p> required <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for authentication</p> <code>None</code> Source code in <code>framewise_meet_client/connection.py</code> <pre><code>def __init__(self, host: str, port: int, meeting_id: str, api_key: Optional[str] = None):\n    \"\"\"Initialize the connection.\n\n    Args:\n        host: Server hostname\n        port: Server port\n        meeting_id: ID of the meeting to join\n        api_key: Optional API key for authentication\n    \"\"\"\n    self.host = host\n    self.port = port\n    self.meeting_id = meeting_id\n    self.api_key = api_key\n    self.websocket = None\n    self.connected = False\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to the WebSocket server.</p> Source code in <code>framewise_meet_client/connection.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connect to the WebSocket server.\"\"\"\n    url = f\"ws://{self.host}:{self.port}/listen/{self.meeting_id}\"\n\n    # Add API key to headers if provided\n    headers = {}\n    if self.api_key:\n        headers[\"Authorization\"] = f\"Bearer {self.api_key}\"\n        logger.debug(\"Added API key to connection headers\")\n\n    try:\n        self.websocket = await websockets.connect(url)\n        self.connected = True\n        logger.info(f\"Connected to server at {url}\")\n\n        # Wait for auth confirmation if API key was provided\n        if self.api_key:\n            try:\n                # Wait for auth confirmation message with timeout\n                auth_message = await asyncio.wait_for(self.websocket.recv(), timeout=5.0)\n                auth_data = json.loads(auth_message)\n\n                if auth_data.get(\"type\") == \"auth_result\" and not auth_data.get(\"success\", False):\n                    logger.error(\"Authentication rejected by server\")\n                    await self.disconnect()\n                    raise AuthenticationError(\"Authentication rejected by server\")\n\n                logger.info(\"Server authenticated connection\")\n\n            except asyncio.TimeoutError:\n                # If we don't get an explicit auth confirmation, assume it's OK\n                logger.warning(\"No explicit authentication confirmation from server\")\n\n\n    except Exception as e:\n        self.connected = False\n        logger.error(f\"Failed to connect: {str(e)}\")\n        raise ConnectionError(f\"Failed to connect: {str(e)}\")\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnect from the WebSocket server.</p> Source code in <code>framewise_meet_client/connection.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the WebSocket server.\"\"\"\n    if self.websocket and self.connected:\n        await self.websocket.close()\n        self.connected = False\n        logger.info(\"Disconnected from server\")\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.send","title":"<code>send(message)</code>  <code>async</code>","text":"<p>Send a message to the server.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Dict[str, Any]</code> <p>JSON-serializable message to send</p> required Source code in <code>framewise_meet_client/connection.py</code> <pre><code>async def send(self, message: Dict[str, Any]) -&gt; None:\n    \"\"\"Send a message to the server.\n\n    Args:\n        message: JSON-serializable message to send\n    \"\"\"\n    if not self.connected or not self.websocket:\n        raise ConnectionError(\"Not connected to server\")\n\n    try:\n        await self.websocket.send(json.dumps(message))\n    except Exception as e:\n        logger.error(f\"Failed to send message: {str(e)}\")\n        raise ConnectionError(f\"Failed to send message: {str(e)}\")\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.send_json","title":"<code>send_json(message)</code>  <code>async</code>","text":"<p>Send a JSON serializable message to the server.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>JSON-serializable message to send</p> required Source code in <code>framewise_meet_client/connection.py</code> <pre><code>async def send_json(self,message):\n    \"\"\"Send a JSON serializable message to the server.\n\n    Args:\n        message: JSON-serializable message to send\n    \"\"\"\n    # This is an alias for the send method\n    return await self.send(message)\n</code></pre>"},{"location":"reference/connection/#framewise_meet_client.connection.WebSocketConnection.receive","title":"<code>receive()</code>  <code>async</code>","text":"<p>Receive a message from the server.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Parsed JSON message from the server</p> Source code in <code>framewise_meet_client/connection.py</code> <pre><code>async def receive(self) -&gt; Dict[str, Any]:\n    \"\"\"Receive a message from the server.\n\n    Returns:\n        Parsed JSON message from the server\n    \"\"\"\n    if not self.connected or not self.websocket:\n        raise ConnectionError(\"Not connected to server\")\n\n    try:\n        message = await self.websocket.recv()\n        return json.loads(message)\n    except websockets.exceptions.ConnectionClosed:\n        self.connected = False\n        logger.warning(\"Connection closed\")\n        raise ConnectionError(\"Connection closed\")\n    except Exception as e:\n        logger.error(f\"Failed to receive message: {str(e)}\")\n        raise ConnectionError(f\"Failed to receive message: {str(e)}\")\n</code></pre>"},{"location":"reference/errors/","title":"errors","text":""},{"location":"reference/errors/#framewise_meet_client.errors","title":"<code>framewise_meet_client.errors</code>","text":""},{"location":"reference/errors/#framewise_meet_client.errors.AppError","title":"<code>AppError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception class for application errors.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class AppError(Exception):\n    \"\"\"Base exception class for application errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/errors/#framewise_meet_client.errors.AppNotRunningError","title":"<code>AppNotRunningError</code>","text":"<p>               Bases: <code>AppError</code></p> <p>Exception raised when an operation requires the app to be running.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class AppNotRunningError(AppError):\n    \"\"\"Exception raised when an operation requires the app to be running.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/errors/#framewise_meet_client.errors.ConnectionError","title":"<code>ConnectionError</code>","text":"<p>               Bases: <code>AppError</code></p> <p>Exception raised for WebSocket connection errors.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class ConnectionError(AppError):\n    \"\"\"Exception raised for WebSocket connection errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/errors/#framewise_meet_client.errors.HandlerError","title":"<code>HandlerError</code>","text":"<p>               Bases: <code>AppError</code></p> <p>Exception raised for errors in event handlers.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class HandlerError(AppError):\n    \"\"\"Exception raised for errors in event handlers.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/errors/#framewise_meet_client.errors.MessageError","title":"<code>MessageError</code>","text":"<p>               Bases: <code>AppError</code></p> <p>Exception raised for errors in message processing.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class MessageError(AppError):\n    \"\"\"Exception raised for errors in message processing.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/errors/#framewise_meet_client.errors.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>               Bases: <code>AppError</code></p> <p>Exception raised for authentication errors.</p> Source code in <code>framewise_meet_client/errors.py</code> <pre><code>class AuthenticationError(AppError):\n    \"\"\"Exception raised for authentication errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/event_handler/","title":"event_handler","text":""},{"location":"reference/event_handler/#framewise_meet_client.event_handler","title":"<code>framewise_meet_client.event_handler</code>","text":""},{"location":"reference/event_handler/#framewise_meet_client.event_handler.EventDispatcher","title":"<code>EventDispatcher</code>","text":"<p>Manages event handlers and dispatches events.</p> Source code in <code>framewise_meet_client/event_handler.py</code> <pre><code>class EventDispatcher:\n    \"\"\"Manages event handlers and dispatches events.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the event dispatcher.\"\"\"\n        self.handlers = {}\n\n    def register_handler(self, event_type: str):\n        \"\"\"Register a handler for a specific event type.\n\n        Args:\n            event_type: Type of event to handle\n\n        Returns:\n            Decorator function\n        \"\"\"\n        def decorator(func):\n            if event_type not in self.handlers:\n                self.handlers[event_type] = []\n            self.handlers[event_type].append(func)\n            logger.debug(f\"Registered handler {func.__name__} for {event_type} events\")\n            return func\n        return decorator\n\n    async def dispatch(self, event_type: str, data: Dict[str, Any]) -&gt; None:\n        \"\"\"Dispatch an event to all registered handlers.\n\n        Args:\n            event_type: Type of event\n            data: Event data\n        \"\"\"\n        if event_type not in self.handlers:\n            logger.debug(f\"No handlers registered for event type: {event_type}\")\n            return\n\n        handler_count = len(self.handlers[event_type])\n        logger.debug(f\"Dispatching {event_type} event to {handler_count} handler(s)\")\n\n        for handler in self.handlers[event_type]:\n            try:\n                logger.debug(f\"Calling handler {handler.__name__} for {event_type} event\")\n                result = handler(data)\n                if asyncio.iscoroutine(result):\n                    await result\n            except Exception as e:\n                logger.error(f\"Error in {event_type} handler {handler.__name__}: {str(e)}\", exc_info=True)\n</code></pre>"},{"location":"reference/event_handler/#framewise_meet_client.event_handler.EventDispatcher.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the event dispatcher.</p> Source code in <code>framewise_meet_client/event_handler.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the event dispatcher.\"\"\"\n    self.handlers = {}\n</code></pre>"},{"location":"reference/event_handler/#framewise_meet_client.event_handler.EventDispatcher.register_handler","title":"<code>register_handler(event_type)</code>","text":"<p>Register a handler for a specific event type.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event to handle</p> required <p>Returns:</p> Type Description <p>Decorator function</p> Source code in <code>framewise_meet_client/event_handler.py</code> <pre><code>def register_handler(self, event_type: str):\n    \"\"\"Register a handler for a specific event type.\n\n    Args:\n        event_type: Type of event to handle\n\n    Returns:\n        Decorator function\n    \"\"\"\n    def decorator(func):\n        if event_type not in self.handlers:\n            self.handlers[event_type] = []\n        self.handlers[event_type].append(func)\n        logger.debug(f\"Registered handler {func.__name__} for {event_type} events\")\n        return func\n    return decorator\n</code></pre>"},{"location":"reference/event_handler/#framewise_meet_client.event_handler.EventDispatcher.dispatch","title":"<code>dispatch(event_type, data)</code>  <code>async</code>","text":"<p>Dispatch an event to all registered handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Event data</p> required Source code in <code>framewise_meet_client/event_handler.py</code> <pre><code>async def dispatch(self, event_type: str, data: Dict[str, Any]) -&gt; None:\n    \"\"\"Dispatch an event to all registered handlers.\n\n    Args:\n        event_type: Type of event\n        data: Event data\n    \"\"\"\n    if event_type not in self.handlers:\n        logger.debug(f\"No handlers registered for event type: {event_type}\")\n        return\n\n    handler_count = len(self.handlers[event_type])\n    logger.debug(f\"Dispatching {event_type} event to {handler_count} handler(s)\")\n\n    for handler in self.handlers[event_type]:\n        try:\n            logger.debug(f\"Calling handler {handler.__name__} for {event_type} event\")\n            result = handler(data)\n            if asyncio.iscoroutine(result):\n                await result\n        except Exception as e:\n            logger.error(f\"Error in {event_type} handler {handler.__name__}: {str(e)}\", exc_info=True)\n</code></pre>"},{"location":"reference/logging_config/","title":"logging_config","text":""},{"location":"reference/logging_config/#framewise_meet_client.logging_config","title":"<code>framewise_meet_client.logging_config</code>","text":""},{"location":"reference/logging_config/#framewise_meet_client.logging_config.configure_logging","title":"<code>configure_logging(level='INFO', log_file=None)</code>","text":"<p>Configure logging for the application.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Log level string (DEBUG, INFO, WARNING, ERROR, CRITICAL)</p> <code>'INFO'</code> <code>log_file</code> <code>Optional[str]</code> <p>Optional file path to write logs to</p> <code>None</code> Source code in <code>framewise_meet_client/logging_config.py</code> <pre><code>def configure_logging(level: str = \"INFO\", log_file: Optional[str] = None):\n    \"\"\"Configure logging for the application.\n\n    Args:\n        level: Log level string (DEBUG, INFO, WARNING, ERROR, CRITICAL)\n        log_file: Optional file path to write logs to\n    \"\"\"\n    # Get the numeric level\n    numeric_level = getattr(logging, level.upper(), None)\n    if not isinstance(numeric_level, int):\n        raise ValueError(f\"Invalid log level: {level}\")\n\n    # Create handlers\n    handlers = [logging.StreamHandler(sys.stdout)]\n\n    if log_file:\n        handlers.append(logging.FileHandler(log_file))\n\n    # Configure logging\n    logging.basicConfig(\n        level=numeric_level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=handlers\n    )\n\n    # Set more restrictive levels for some verbose libraries\n    logging.getLogger('websockets').setLevel(max(numeric_level, logging.INFO))\n    logging.getLogger('asyncio').setLevel(max(numeric_level, logging.INFO))\n\n    logging.info(f\"Logging configured with level {level}\")\n\n    return logging.getLogger()\n</code></pre>"},{"location":"reference/messaging/","title":"messaging","text":""},{"location":"reference/messaging/#framewise_meet_client.messaging","title":"<code>framewise_meet_client.messaging</code>","text":""},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender","title":"<code>MessageSender</code>","text":"<p>Manages sending messages to the server.</p> Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>class MessageSender:\n    \"\"\"Manages sending messages to the server.\"\"\"\n\n    def __init__(self, connection):\n        \"\"\"Initialize the message sender.\n\n        Args:\n            connection: WebSocketConnection instance\n        \"\"\"\n        self.connection = connection\n\n    async def _send_message(self, message: Dict[str, Any]) -&gt; None:\n        \"\"\"Send a message over the WebSocket connection.\n\n        Args:\n            message: Message data to send\n\n        Raises:\n            ConnectionError: If the connection is not established\n        \"\"\"\n        if not self.connection or not self.connection.connected:\n            raise ConnectionError(\"Not connected to server\")\n\n        try:\n            await self.connection.send_json(message)\n            logger.debug(f\"Sent message: {json.dumps(message)[:100]}...\")\n        except Exception as e:\n            logger.error(f\"Error sending message: {str(e)}\")\n            raise ConnectionError(f\"Failed to send message: {str(e)}\")\n\n    def send_generated_text(self, text: str, is_generation_end: bool = False, loop: asyncio.AbstractEventLoop = None) -&gt; None:\n        \"\"\"Send generated text to the server.\n\n        Args:\n            text: The generated text\n            is_generation_end: Whether this is the end of generation\n            loop: Event loop to use for coroutine execution (uses current loop if None)\n        \"\"\"\n        message = {\n            \"type\": \"generated_text\",\n            \"content\": {\n                \"text\": text,\n                \"is_generation_end\": is_generation_end\n            }\n        }\n\n        if loop:\n            asyncio.run_coroutine_threadsafe(self._send_message(message), loop)\n        else:\n            asyncio.create_task(self._send_message(message))\n\n    def send_custom_ui_element(self, ui_type: str, data: Dict[str, Any], loop: asyncio.AbstractEventLoop = None) -&gt; None:\n        \"\"\"Send a custom UI element to the server.\n\n        Args:\n            ui_type: Type of UI element (e.g., 'mcq_question')\n            data: Element-specific data\n            loop: Event loop to use for coroutine execution (uses current loop if None)\n        \"\"\"\n        message = {\n            \"type\": \"custom_ui_element\",\n            \"content\": {\n                \"type\": ui_type,\n                \"data\": data\n            }\n        }\n\n        if loop:\n            asyncio.run_coroutine_threadsafe(self._send_message(message), loop)\n        else:\n            asyncio.create_task(self._send_message(message))\n\n    def send_mcq_question(self, question_id: str, question: str, options: List[str],\n                         loop: asyncio.AbstractEventLoop = None, image_path: Optional[str] = None) -&gt; None:\n        \"\"\"Send an MCQ question as a custom UI element.\n\n        Args:\n            question_id: Unique identifier for the question\n            question: The question text\n            options: List of answer options\n            loop: Event loop to use for coroutine execution (uses current loop if None)\n            image_path: Optional path to an image to display with the question\n        \"\"\"\n        data = {\n            \"id\": question_id,\n            \"question\": question,\n            \"options\": options\n        }\n\n        if image_path:\n            data[\"image_path\"] = image_path\n\n        self.send_custom_ui_element(\"mcq_question\", data, loop)\n\n    def send_notification(self, message: str, level: str = \"info\", duration: int = 8000,\n                         loop: Optional[asyncio.AbstractEventLoop] = None) -&gt; None:\n        \"\"\"Send a notification to all users in the meeting.\n\n        Args:\n            message: The notification message to display\n            level: The notification level (info, warning, error, success)\n            duration: How long the notification should display (in milliseconds)\n            loop: Event loop to run the coroutine in\n        \"\"\"\n        data = {\n            \"message\": message,\n            \"level\": level,\n            \"duration\": duration\n        }\n\n        self.send_custom_ui_element(\"notification_element\", data, loop)\n</code></pre>"},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender.__init__","title":"<code>__init__(connection)</code>","text":"<p>Initialize the message sender.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <p>WebSocketConnection instance</p> required Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>def __init__(self, connection):\n    \"\"\"Initialize the message sender.\n\n    Args:\n        connection: WebSocketConnection instance\n    \"\"\"\n    self.connection = connection\n</code></pre>"},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender.send_generated_text","title":"<code>send_generated_text(text, is_generation_end=False, loop=None)</code>","text":"<p>Send generated text to the server.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The generated text</p> required <code>is_generation_end</code> <code>bool</code> <p>Whether this is the end of generation</p> <code>False</code> <code>loop</code> <code>AbstractEventLoop</code> <p>Event loop to use for coroutine execution (uses current loop if None)</p> <code>None</code> Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>def send_generated_text(self, text: str, is_generation_end: bool = False, loop: asyncio.AbstractEventLoop = None) -&gt; None:\n    \"\"\"Send generated text to the server.\n\n    Args:\n        text: The generated text\n        is_generation_end: Whether this is the end of generation\n        loop: Event loop to use for coroutine execution (uses current loop if None)\n    \"\"\"\n    message = {\n        \"type\": \"generated_text\",\n        \"content\": {\n            \"text\": text,\n            \"is_generation_end\": is_generation_end\n        }\n    }\n\n    if loop:\n        asyncio.run_coroutine_threadsafe(self._send_message(message), loop)\n    else:\n        asyncio.create_task(self._send_message(message))\n</code></pre>"},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender.send_custom_ui_element","title":"<code>send_custom_ui_element(ui_type, data, loop=None)</code>","text":"<p>Send a custom UI element to the server.</p> <p>Parameters:</p> Name Type Description Default <code>ui_type</code> <code>str</code> <p>Type of UI element (e.g., 'mcq_question')</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Element-specific data</p> required <code>loop</code> <code>AbstractEventLoop</code> <p>Event loop to use for coroutine execution (uses current loop if None)</p> <code>None</code> Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>def send_custom_ui_element(self, ui_type: str, data: Dict[str, Any], loop: asyncio.AbstractEventLoop = None) -&gt; None:\n    \"\"\"Send a custom UI element to the server.\n\n    Args:\n        ui_type: Type of UI element (e.g., 'mcq_question')\n        data: Element-specific data\n        loop: Event loop to use for coroutine execution (uses current loop if None)\n    \"\"\"\n    message = {\n        \"type\": \"custom_ui_element\",\n        \"content\": {\n            \"type\": ui_type,\n            \"data\": data\n        }\n    }\n\n    if loop:\n        asyncio.run_coroutine_threadsafe(self._send_message(message), loop)\n    else:\n        asyncio.create_task(self._send_message(message))\n</code></pre>"},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender.send_mcq_question","title":"<code>send_mcq_question(question_id, question, options, loop=None, image_path=None)</code>","text":"<p>Send an MCQ question as a custom UI element.</p> <p>Parameters:</p> Name Type Description Default <code>question_id</code> <code>str</code> <p>Unique identifier for the question</p> required <code>question</code> <code>str</code> <p>The question text</p> required <code>options</code> <code>List[str]</code> <p>List of answer options</p> required <code>loop</code> <code>AbstractEventLoop</code> <p>Event loop to use for coroutine execution (uses current loop if None)</p> <code>None</code> <code>image_path</code> <code>Optional[str]</code> <p>Optional path to an image to display with the question</p> <code>None</code> Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>def send_mcq_question(self, question_id: str, question: str, options: List[str],\n                     loop: asyncio.AbstractEventLoop = None, image_path: Optional[str] = None) -&gt; None:\n    \"\"\"Send an MCQ question as a custom UI element.\n\n    Args:\n        question_id: Unique identifier for the question\n        question: The question text\n        options: List of answer options\n        loop: Event loop to use for coroutine execution (uses current loop if None)\n        image_path: Optional path to an image to display with the question\n    \"\"\"\n    data = {\n        \"id\": question_id,\n        \"question\": question,\n        \"options\": options\n    }\n\n    if image_path:\n        data[\"image_path\"] = image_path\n\n    self.send_custom_ui_element(\"mcq_question\", data, loop)\n</code></pre>"},{"location":"reference/messaging/#framewise_meet_client.messaging.MessageSender.send_notification","title":"<code>send_notification(message, level='info', duration=8000, loop=None)</code>","text":"<p>Send a notification to all users in the meeting.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The notification message to display</p> required <code>level</code> <code>str</code> <p>The notification level (info, warning, error, success)</p> <code>'info'</code> <code>duration</code> <code>int</code> <p>How long the notification should display (in milliseconds)</p> <code>8000</code> <code>loop</code> <code>Optional[AbstractEventLoop]</code> <p>Event loop to run the coroutine in</p> <code>None</code> Source code in <code>framewise_meet_client/messaging.py</code> <pre><code>def send_notification(self, message: str, level: str = \"info\", duration: int = 8000,\n                     loop: Optional[asyncio.AbstractEventLoop] = None) -&gt; None:\n    \"\"\"Send a notification to all users in the meeting.\n\n    Args:\n        message: The notification message to display\n        level: The notification level (info, warning, error, success)\n        duration: How long the notification should display (in milliseconds)\n        loop: Event loop to run the coroutine in\n    \"\"\"\n    data = {\n        \"message\": message,\n        \"level\": level,\n        \"duration\": duration\n    }\n\n    self.send_custom_ui_element(\"notification_element\", data, loop)\n</code></pre>"},{"location":"reference/runner/","title":"runner","text":""},{"location":"reference/runner/#framewise_meet_client.runner","title":"<code>framewise_meet_client.runner</code>","text":""},{"location":"reference/runner/#framewise_meet_client.runner.AppRunner","title":"<code>AppRunner</code>","text":"<p>Manages the application's main event loop.</p> Source code in <code>framewise_meet_client/runner.py</code> <pre><code>class AppRunner:\n    \"\"\"Manages the application's main event loop.\"\"\"\n\n    # Message type mapping\n    _message_classes = {\n        \"on_join\": JoinMessage,\n        \"on_exit\": ExitMessage,\n        \"transcript\": TranscriptMessage,\n        \"custom_ui_element_response\": CustomUIElementMessage,\n        \"mcq_selection\": MCQSelectionMessage,\n        \"connection_rejected\": ConnectionRejectedMessage\n    }\n\n    def __init__(self, connection, event_dispatcher, auto_reconnect=True, reconnect_delay=5):\n        \"\"\"Initialize the app runner.\n\n        Args:\n            connection: WebSocketConnection instance\n            event_dispatcher: EventDispatcher instance\n            auto_reconnect: Whether to automatically reconnect on disconnect\n            reconnect_delay: Delay between reconnection attempts in seconds\n        \"\"\"\n        self.connection = connection\n        self.event_dispatcher = event_dispatcher\n        self.auto_reconnect = auto_reconnect\n        self.reconnect_delay = reconnect_delay\n\n    def _convert_message(self, message_type: str, data: Dict[str, Any]) -&gt; Optional[BaseMessage]:\n        \"\"\"Convert raw message data to appropriate message object.\n\n        Args:\n            message_type: Type of message\n            data: Raw message data\n\n        Returns:\n            Converted message object or None if conversion failed\n        \"\"\"\n        message_class = self._message_classes.get(message_type)\n        if not message_class:\n            return None\n\n        try:\n            logger.debug(f\"Converting raw data to {message_class.__name__}\")\n            return message_class.model_validate(data)\n        except ValidationError as e:\n            logger.warning(f\"Validation error converting {message_type}: {e}\")\n            return None\n        except Exception as e:\n            logger.warning(f\"Unexpected error converting {message_type}: {e}\")\n            return None\n\n    async def _listen(self) -&gt; None:\n        \"\"\"Listen for incoming messages and dispatch to handlers.\"\"\"\n        try:\n            while self.connection.connected:\n                data = await self.connection.receive()\n\n                logger.info(data)\n                if \"type\" not in data:\n                    logger.warning(\"Received message without type field\")\n                    continue\n\n                message_type = data[\"type\"]\n\n                # Special handling for connection_rejected messages\n                if message_type == \"connection_rejected\":\n                    rejected_message = ConnectionRejectedMessage.model_validate(data)\n                    logger.warning(f\"Connection rejected: {rejected_message.content.reason}\")\n                    await self.event_dispatcher.dispatch(\"connection_rejected\", rejected_message)\n\n                    # Stop the connection if rejected\n                    self.app.running = False\n                    break\n\n                # Always try to convert every message to its proper type\n                converted = None\n                message_class = self._message_classes.get(message_type)\n\n                if message_class is not None:\n                    try:\n                        converted = message_class.model_validate(data)\n                        logger.debug(f\"Successfully converted to {message_class.__name__}\")\n                    except Exception as e:\n                        logger.warning(f\"Failed to convert {message_type} to {message_class.__name__}: {e}\")\n\n                # Dispatch the converted message if available, raw data otherwise\n                await self.event_dispatcher.dispatch(message_type, converted or data)\n\n                # Handle special events\n                if message_type == \"transcript\":\n                    # Check if this is a final transcript\n                    is_final = False\n                    if converted and isinstance(converted, TranscriptMessage):\n                        is_final = converted.content.is_final\n                    elif isinstance(data, dict):\n                        try:\n                            is_final = data.get(\"content\", {}).get(\"is_final\", False)\n                        except:\n                            pass\n\n                    if is_final:\n                        logger.debug(\"Final transcript detected, triggering invoke event\")\n                        await self.event_dispatcher.dispatch(INVOKE_EVENT, converted or data)\n\n                # Handle UI subtypes\n                elif message_type == \"custom_ui_element_response\":\n                    ui_subtype = None\n                    if converted and isinstance(converted, CustomUIElementMessage):\n                        ui_subtype = converted.content.type\n                    elif isinstance(data, dict):\n                        try:\n                            ui_subtype = data.get(\"content\", {}).get(\"type\")\n                        except:\n                            pass\n\n                    if ui_subtype:\n                        logger.debug(f\"Dispatching to UI subtype: {ui_subtype}\")\n                        await self.event_dispatcher.dispatch(ui_subtype, converted or data)\n\n        except ConnectionError as e:\n            logger.warning(f\"Connection error: {str(e)}\")\n\n    async def _main_loop(self) -&gt; None:\n        \"\"\"Main application loop.\"\"\"\n        try:\n            while self.app.running:\n                try:\n                    await self.connection.connect()\n                    await self._listen()\n                except Exception as e:\n                    logger.error(f\"Connection error: {str(e)}\")\n\n                if not self.auto_reconnect or not self.app.running:\n                    break\n\n                logger.info(f\"Reconnecting in {self.reconnect_delay} seconds...\")\n                await asyncio.sleep(self.reconnect_delay)\n\n        finally:\n            # Clean up on exit\n            if self.connection.connected:\n                await self.connection.disconnect()\n\n    def _handle_signal(self, sig, frame):\n        \"\"\"Handle termination signals.\"\"\"\n        logger.info(f\"Received signal {sig}, shutting down...\")\n        self.app.stop()\n\n    def run(self, app):\n        \"\"\"Run the application (blocking).\"\"\"\n        self.app = app\n\n        # Set up signal handlers for graceful shutdown\n        signal.signal(signal.SIGINT, self._handle_signal)\n        signal.signal(signal.SIGTERM, self._handle_signal)\n\n        # Create a new event loop in this thread\n        self.app.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.app.loop)\n\n        try:\n            self.app.running = True\n            self.app._main_task = self.app.loop.create_task(self._main_loop())\n            self.app.loop.run_until_complete(self.app._main_task)\n        except KeyboardInterrupt:\n            logger.info(\"Application stopped by user\")\n        finally:\n            # Clean up\n            self.app.running = False\n\n            # Cancel the main task if it's still running\n            if self.app._main_task and not self.app._main_task.done():\n                self.app._main_task.cancel()\n                try:\n                    self.app.loop.run_until_complete(self.app._main_task)\n                except asyncio.CancelledError:\n                    pass\n\n            # Close the event loop\n            self.app.loop.close()\n            self.app.loop = None\n</code></pre>"},{"location":"reference/runner/#framewise_meet_client.runner.AppRunner.__init__","title":"<code>__init__(connection, event_dispatcher, auto_reconnect=True, reconnect_delay=5)</code>","text":"<p>Initialize the app runner.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <p>WebSocketConnection instance</p> required <code>event_dispatcher</code> <p>EventDispatcher instance</p> required <code>auto_reconnect</code> <p>Whether to automatically reconnect on disconnect</p> <code>True</code> <code>reconnect_delay</code> <p>Delay between reconnection attempts in seconds</p> <code>5</code> Source code in <code>framewise_meet_client/runner.py</code> <pre><code>def __init__(self, connection, event_dispatcher, auto_reconnect=True, reconnect_delay=5):\n    \"\"\"Initialize the app runner.\n\n    Args:\n        connection: WebSocketConnection instance\n        event_dispatcher: EventDispatcher instance\n        auto_reconnect: Whether to automatically reconnect on disconnect\n        reconnect_delay: Delay between reconnection attempts in seconds\n    \"\"\"\n    self.connection = connection\n    self.event_dispatcher = event_dispatcher\n    self.auto_reconnect = auto_reconnect\n    self.reconnect_delay = reconnect_delay\n</code></pre>"},{"location":"reference/runner/#framewise_meet_client.runner.AppRunner.run","title":"<code>run(app)</code>","text":"<p>Run the application (blocking).</p> Source code in <code>framewise_meet_client/runner.py</code> <pre><code>def run(self, app):\n    \"\"\"Run the application (blocking).\"\"\"\n    self.app = app\n\n    # Set up signal handlers for graceful shutdown\n    signal.signal(signal.SIGINT, self._handle_signal)\n    signal.signal(signal.SIGTERM, self._handle_signal)\n\n    # Create a new event loop in this thread\n    self.app.loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(self.app.loop)\n\n    try:\n        self.app.running = True\n        self.app._main_task = self.app.loop.create_task(self._main_loop())\n        self.app.loop.run_until_complete(self.app._main_task)\n    except KeyboardInterrupt:\n        logger.info(\"Application stopped by user\")\n    finally:\n        # Clean up\n        self.app.running = False\n\n        # Cancel the main task if it's still running\n        if self.app._main_task and not self.app._main_task.done():\n            self.app._main_task.cancel()\n            try:\n                self.app.loop.run_until_complete(self.app._main_task)\n            except asyncio.CancelledError:\n                pass\n\n        # Close the event loop\n        self.app.loop.close()\n        self.app.loop = None\n</code></pre>"},{"location":"reference/events/","title":"events","text":""},{"location":"reference/events/#framewise_meet_client.events","title":"<code>framewise_meet_client.events</code>","text":""},{"location":"reference/events/#framewise_meet_client.events.EventHandler","title":"<code>EventHandler</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Base class for event handlers.</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>class EventHandler(Generic[T]):\n    \"\"\"Base class for event handlers.\"\"\"\n\n    event_type: str = \"\"\n    message_class: Type[BaseMessage] = None\n\n    def __init__(self, dispatcher):\n        \"\"\"Initialize the event handler.\n\n        Args:\n            dispatcher: Event dispatcher instance\n        \"\"\"\n        self.dispatcher = dispatcher\n\n    def register(self, handler_func: Callable[[T], Any]) -&gt; Callable[[Union[Dict[str, Any], T]], Any]:\n        \"\"\"Register a handler function for this event type.\n\n        Args:\n            handler_func: Function that takes a strongly-typed message object\n\n        Returns:\n            The original handler function for chaining\n        \"\"\"\n        def wrapper(data):\n            # Always convert data to proper message class\n            if isinstance(data, dict) and self.message_class is not None:\n                try:\n                    converted = self.message_class.model_validate(data)\n                    return handler_func(converted)\n                except Exception as e:\n                    logger.error(f\"Failed to convert dict to {self.message_class.__name__}: {e}\")\n                    # Try to create an empty instance as fallback with minimal data\n                    try:\n                        if \"type\" in data:\n                            minimal_data = {\"type\": data[\"type\"], \"content\": {}}\n                            if \"content\" in data and isinstance(data[\"content\"], dict):\n                                minimal_data[\"content\"] = data[\"content\"]\n                            converted = self.message_class.model_validate(minimal_data)\n                            logger.warning(f\"Created minimal {self.message_class.__name__} instance\")\n                            return handler_func(converted)\n                    except Exception as inner_e:\n                        logger.error(f\"Could not create minimal instance: {inner_e}\")\n                        raise ValueError(f\"Cannot handle event: failed to convert to {self.message_class.__name__}\")\n            elif isinstance(data, self.message_class):\n                # Already the correct type\n                return handler_func(data)\n            else:\n                # Unknown data type\n                logger.error(f\"Unexpected data type for {self.event_type}: {type(data)}\")\n                raise TypeError(f\"Expected {self.message_class.__name__}, got {type(data)}\")\n\n        logger.info(f\"Registered handler for {self.event_type} events using {self.message_class.__name__}\")\n        self.dispatcher.register_handler(self.event_type)(wrapper)\n        return handler_func\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.EventHandler.__init__","title":"<code>__init__(dispatcher)</code>","text":"<p>Initialize the event handler.</p> <p>Parameters:</p> Name Type Description Default <code>dispatcher</code> <p>Event dispatcher instance</p> required Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def __init__(self, dispatcher):\n    \"\"\"Initialize the event handler.\n\n    Args:\n        dispatcher: Event dispatcher instance\n    \"\"\"\n    self.dispatcher = dispatcher\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.EventHandler.register","title":"<code>register(handler_func)</code>","text":"<p>Register a handler function for this event type.</p> <p>Parameters:</p> Name Type Description Default <code>handler_func</code> <code>Callable[[T], Any]</code> <p>Function that takes a strongly-typed message object</p> required <p>Returns:</p> Type Description <code>Callable[[Union[Dict[str, Any], T]], Any]</code> <p>The original handler function for chaining</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def register(self, handler_func: Callable[[T], Any]) -&gt; Callable[[Union[Dict[str, Any], T]], Any]:\n    \"\"\"Register a handler function for this event type.\n\n    Args:\n        handler_func: Function that takes a strongly-typed message object\n\n    Returns:\n        The original handler function for chaining\n    \"\"\"\n    def wrapper(data):\n        # Always convert data to proper message class\n        if isinstance(data, dict) and self.message_class is not None:\n            try:\n                converted = self.message_class.model_validate(data)\n                return handler_func(converted)\n            except Exception as e:\n                logger.error(f\"Failed to convert dict to {self.message_class.__name__}: {e}\")\n                # Try to create an empty instance as fallback with minimal data\n                try:\n                    if \"type\" in data:\n                        minimal_data = {\"type\": data[\"type\"], \"content\": {}}\n                        if \"content\" in data and isinstance(data[\"content\"], dict):\n                            minimal_data[\"content\"] = data[\"content\"]\n                        converted = self.message_class.model_validate(minimal_data)\n                        logger.warning(f\"Created minimal {self.message_class.__name__} instance\")\n                        return handler_func(converted)\n                except Exception as inner_e:\n                    logger.error(f\"Could not create minimal instance: {inner_e}\")\n                    raise ValueError(f\"Cannot handle event: failed to convert to {self.message_class.__name__}\")\n        elif isinstance(data, self.message_class):\n            # Already the correct type\n            return handler_func(data)\n        else:\n            # Unknown data type\n            logger.error(f\"Unexpected data type for {self.event_type}: {type(data)}\")\n            raise TypeError(f\"Expected {self.message_class.__name__}, got {type(data)}\")\n\n    logger.info(f\"Registered handler for {self.event_type} events using {self.message_class.__name__}\")\n    self.dispatcher.register_handler(self.event_type)(wrapper)\n    return handler_func\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.TranscriptHandler","title":"<code>TranscriptHandler</code>","text":"<p>               Bases: <code>EventHandler[TranscriptMessage]</code></p> <p>Handler for transcript events.</p> Source code in <code>framewise_meet_client/events/transcript_handler.py</code> <pre><code>class TranscriptHandler(EventHandler[TranscriptMessage]):\n    \"\"\"Handler for transcript events.\"\"\"\n\n    event_type = \"transcript\"\n    message_class = TranscriptMessage\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.JoinHandler","title":"<code>JoinHandler</code>","text":"<p>               Bases: <code>EventHandler[JoinMessage]</code></p> <p>Handler for join events.</p> Source code in <code>framewise_meet_client/events/join_handler.py</code> <pre><code>class JoinHandler(EventHandler[JoinMessage]):\n    \"\"\"Handler for join events.\"\"\"\n\n    event_type = \"on_join\"\n    message_class = JoinMessage\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.ExitHandler","title":"<code>ExitHandler</code>","text":"<p>               Bases: <code>EventHandler[ExitMessage]</code></p> <p>Handler for exit events.</p> Source code in <code>framewise_meet_client/events/exit_handler.py</code> <pre><code>class ExitHandler(EventHandler[ExitMessage]):\n    \"\"\"Handler for exit events.\"\"\"\n\n    event_type = \"on_exit\"\n    message_class = ExitMessage\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.CustomUIHandler","title":"<code>CustomUIHandler</code>","text":"<p>               Bases: <code>EventHandler[CustomUIElementMessage]</code></p> <p>Handler for custom UI element response events.</p> Source code in <code>framewise_meet_client/events/custom_ui_handler.py</code> <pre><code>class CustomUIHandler(EventHandler[CustomUIElementMessage]):\n    \"\"\"Handler for custom UI element response events.\"\"\"\n\n    event_type = \"custom_ui_element_response\"\n    message_class = CustomUIElementMessage\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.InvokeHandler","title":"<code>InvokeHandler</code>","text":"<p>               Bases: <code>EventHandler[TranscriptMessage]</code></p> <p>Handler for invoke events (triggered by final transcripts).</p> Source code in <code>framewise_meet_client/events/invoke_handler.py</code> <pre><code>class InvokeHandler(EventHandler[TranscriptMessage]):\n    \"\"\"Handler for invoke events (triggered by final transcripts).\"\"\"\n\n    event_type = \"invoke\"\n    message_class = TranscriptMessage\n</code></pre>"},{"location":"reference/events/#framewise_meet_client.events.register_event_handler","title":"<code>register_event_handler(app, event_type, handler_func)</code>","text":"<p>Register a handler function for the given event type.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <p>App instance</p> required <code>event_type</code> <code>str</code> <p>Event type string</p> required <code>handler_func</code> <code>Callable</code> <p>Function to handle the event</p> required <p>Returns:</p> Type Description <p>The original handler function for chaining</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def register_event_handler(app, event_type: str, handler_func: Callable):\n    \"\"\"Register a handler function for the given event type.\n\n    Args:\n        app: App instance\n        event_type: Event type string\n        handler_func: Function to handle the event\n\n    Returns:\n        The original handler function for chaining\n    \"\"\"\n    from . import EVENT_HANDLERS\n\n    if event_type not in EVENT_HANDLERS:\n        logger.warning(f\"Unknown event type: {event_type}. Falling back to generic registration.\")\n        # Fall back to generic registration\n        return app.event_dispatcher.register_handler(event_type)(handler_func)\n\n    handler_class = EVENT_HANDLERS[event_type]\n    handler = handler_class(app.event_dispatcher)\n    logger.debug(f\"Using {handler_class.__name__} for event type '{event_type}'\")\n    return handler.register(handler_func)\n</code></pre>"},{"location":"reference/events/base_handler/","title":"base_handler","text":""},{"location":"reference/events/base_handler/#framewise_meet_client.events.base_handler","title":"<code>framewise_meet_client.events.base_handler</code>","text":""},{"location":"reference/events/base_handler/#framewise_meet_client.events.base_handler.EventHandler","title":"<code>EventHandler</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Base class for event handlers.</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>class EventHandler(Generic[T]):\n    \"\"\"Base class for event handlers.\"\"\"\n\n    event_type: str = \"\"\n    message_class: Type[BaseMessage] = None\n\n    def __init__(self, dispatcher):\n        \"\"\"Initialize the event handler.\n\n        Args:\n            dispatcher: Event dispatcher instance\n        \"\"\"\n        self.dispatcher = dispatcher\n\n    def register(self, handler_func: Callable[[T], Any]) -&gt; Callable[[Union[Dict[str, Any], T]], Any]:\n        \"\"\"Register a handler function for this event type.\n\n        Args:\n            handler_func: Function that takes a strongly-typed message object\n\n        Returns:\n            The original handler function for chaining\n        \"\"\"\n        def wrapper(data):\n            # Always convert data to proper message class\n            if isinstance(data, dict) and self.message_class is not None:\n                try:\n                    converted = self.message_class.model_validate(data)\n                    return handler_func(converted)\n                except Exception as e:\n                    logger.error(f\"Failed to convert dict to {self.message_class.__name__}: {e}\")\n                    # Try to create an empty instance as fallback with minimal data\n                    try:\n                        if \"type\" in data:\n                            minimal_data = {\"type\": data[\"type\"], \"content\": {}}\n                            if \"content\" in data and isinstance(data[\"content\"], dict):\n                                minimal_data[\"content\"] = data[\"content\"]\n                            converted = self.message_class.model_validate(minimal_data)\n                            logger.warning(f\"Created minimal {self.message_class.__name__} instance\")\n                            return handler_func(converted)\n                    except Exception as inner_e:\n                        logger.error(f\"Could not create minimal instance: {inner_e}\")\n                        raise ValueError(f\"Cannot handle event: failed to convert to {self.message_class.__name__}\")\n            elif isinstance(data, self.message_class):\n                # Already the correct type\n                return handler_func(data)\n            else:\n                # Unknown data type\n                logger.error(f\"Unexpected data type for {self.event_type}: {type(data)}\")\n                raise TypeError(f\"Expected {self.message_class.__name__}, got {type(data)}\")\n\n        logger.info(f\"Registered handler for {self.event_type} events using {self.message_class.__name__}\")\n        self.dispatcher.register_handler(self.event_type)(wrapper)\n        return handler_func\n</code></pre>"},{"location":"reference/events/base_handler/#framewise_meet_client.events.base_handler.EventHandler.__init__","title":"<code>__init__(dispatcher)</code>","text":"<p>Initialize the event handler.</p> <p>Parameters:</p> Name Type Description Default <code>dispatcher</code> <p>Event dispatcher instance</p> required Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def __init__(self, dispatcher):\n    \"\"\"Initialize the event handler.\n\n    Args:\n        dispatcher: Event dispatcher instance\n    \"\"\"\n    self.dispatcher = dispatcher\n</code></pre>"},{"location":"reference/events/base_handler/#framewise_meet_client.events.base_handler.EventHandler.register","title":"<code>register(handler_func)</code>","text":"<p>Register a handler function for this event type.</p> <p>Parameters:</p> Name Type Description Default <code>handler_func</code> <code>Callable[[T], Any]</code> <p>Function that takes a strongly-typed message object</p> required <p>Returns:</p> Type Description <code>Callable[[Union[Dict[str, Any], T]], Any]</code> <p>The original handler function for chaining</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def register(self, handler_func: Callable[[T], Any]) -&gt; Callable[[Union[Dict[str, Any], T]], Any]:\n    \"\"\"Register a handler function for this event type.\n\n    Args:\n        handler_func: Function that takes a strongly-typed message object\n\n    Returns:\n        The original handler function for chaining\n    \"\"\"\n    def wrapper(data):\n        # Always convert data to proper message class\n        if isinstance(data, dict) and self.message_class is not None:\n            try:\n                converted = self.message_class.model_validate(data)\n                return handler_func(converted)\n            except Exception as e:\n                logger.error(f\"Failed to convert dict to {self.message_class.__name__}: {e}\")\n                # Try to create an empty instance as fallback with minimal data\n                try:\n                    if \"type\" in data:\n                        minimal_data = {\"type\": data[\"type\"], \"content\": {}}\n                        if \"content\" in data and isinstance(data[\"content\"], dict):\n                            minimal_data[\"content\"] = data[\"content\"]\n                        converted = self.message_class.model_validate(minimal_data)\n                        logger.warning(f\"Created minimal {self.message_class.__name__} instance\")\n                        return handler_func(converted)\n                except Exception as inner_e:\n                    logger.error(f\"Could not create minimal instance: {inner_e}\")\n                    raise ValueError(f\"Cannot handle event: failed to convert to {self.message_class.__name__}\")\n        elif isinstance(data, self.message_class):\n            # Already the correct type\n            return handler_func(data)\n        else:\n            # Unknown data type\n            logger.error(f\"Unexpected data type for {self.event_type}: {type(data)}\")\n            raise TypeError(f\"Expected {self.message_class.__name__}, got {type(data)}\")\n\n    logger.info(f\"Registered handler for {self.event_type} events using {self.message_class.__name__}\")\n    self.dispatcher.register_handler(self.event_type)(wrapper)\n    return handler_func\n</code></pre>"},{"location":"reference/events/base_handler/#framewise_meet_client.events.base_handler.register_event_handler","title":"<code>register_event_handler(app, event_type, handler_func)</code>","text":"<p>Register a handler function for the given event type.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <p>App instance</p> required <code>event_type</code> <code>str</code> <p>Event type string</p> required <code>handler_func</code> <code>Callable</code> <p>Function to handle the event</p> required <p>Returns:</p> Type Description <p>The original handler function for chaining</p> Source code in <code>framewise_meet_client/events/base_handler.py</code> <pre><code>def register_event_handler(app, event_type: str, handler_func: Callable):\n    \"\"\"Register a handler function for the given event type.\n\n    Args:\n        app: App instance\n        event_type: Event type string\n        handler_func: Function to handle the event\n\n    Returns:\n        The original handler function for chaining\n    \"\"\"\n    from . import EVENT_HANDLERS\n\n    if event_type not in EVENT_HANDLERS:\n        logger.warning(f\"Unknown event type: {event_type}. Falling back to generic registration.\")\n        # Fall back to generic registration\n        return app.event_dispatcher.register_handler(event_type)(handler_func)\n\n    handler_class = EVENT_HANDLERS[event_type]\n    handler = handler_class(app.event_dispatcher)\n    logger.debug(f\"Using {handler_class.__name__} for event type '{event_type}'\")\n    return handler.register(handler_func)\n</code></pre>"},{"location":"reference/events/connection_rejected_handler/","title":"connection_rejected_handler","text":""},{"location":"reference/events/connection_rejected_handler/#framewise_meet_client.events.connection_rejected_handler","title":"<code>framewise_meet_client.events.connection_rejected_handler</code>","text":""},{"location":"reference/events/connection_rejected_handler/#framewise_meet_client.events.connection_rejected_handler.ConnectionRejectedHandler","title":"<code>ConnectionRejectedHandler</code>","text":"<p>               Bases: <code>EventHandler[ConnectionRejectedMessage]</code></p> <p>Handler for connection rejected events.</p> Source code in <code>framewise_meet_client/events/connection_rejected_handler.py</code> <pre><code>class ConnectionRejectedHandler(EventHandler[ConnectionRejectedMessage]):\n    \"\"\"Handler for connection rejected events.\"\"\"\n\n    event_type = \"connection_rejected\"\n    message_class = ConnectionRejectedMessage\n</code></pre>"},{"location":"reference/events/custom_ui_handler/","title":"custom_ui_handler","text":""},{"location":"reference/events/custom_ui_handler/#framewise_meet_client.events.custom_ui_handler","title":"<code>framewise_meet_client.events.custom_ui_handler</code>","text":""},{"location":"reference/events/custom_ui_handler/#framewise_meet_client.events.custom_ui_handler.CustomUIHandler","title":"<code>CustomUIHandler</code>","text":"<p>               Bases: <code>EventHandler[CustomUIElementMessage]</code></p> <p>Handler for custom UI element response events.</p> Source code in <code>framewise_meet_client/events/custom_ui_handler.py</code> <pre><code>class CustomUIHandler(EventHandler[CustomUIElementMessage]):\n    \"\"\"Handler for custom UI element response events.\"\"\"\n\n    event_type = \"custom_ui_element_response\"\n    message_class = CustomUIElementMessage\n</code></pre>"},{"location":"reference/events/exit_handler/","title":"exit_handler","text":""},{"location":"reference/events/exit_handler/#framewise_meet_client.events.exit_handler","title":"<code>framewise_meet_client.events.exit_handler</code>","text":""},{"location":"reference/events/exit_handler/#framewise_meet_client.events.exit_handler.ExitHandler","title":"<code>ExitHandler</code>","text":"<p>               Bases: <code>EventHandler[ExitMessage]</code></p> <p>Handler for exit events.</p> Source code in <code>framewise_meet_client/events/exit_handler.py</code> <pre><code>class ExitHandler(EventHandler[ExitMessage]):\n    \"\"\"Handler for exit events.\"\"\"\n\n    event_type = \"on_exit\"\n    message_class = ExitMessage\n</code></pre>"},{"location":"reference/events/invoke_handler/","title":"invoke_handler","text":""},{"location":"reference/events/invoke_handler/#framewise_meet_client.events.invoke_handler","title":"<code>framewise_meet_client.events.invoke_handler</code>","text":""},{"location":"reference/events/invoke_handler/#framewise_meet_client.events.invoke_handler.InvokeHandler","title":"<code>InvokeHandler</code>","text":"<p>               Bases: <code>EventHandler[TranscriptMessage]</code></p> <p>Handler for invoke events (triggered by final transcripts).</p> Source code in <code>framewise_meet_client/events/invoke_handler.py</code> <pre><code>class InvokeHandler(EventHandler[TranscriptMessage]):\n    \"\"\"Handler for invoke events (triggered by final transcripts).\"\"\"\n\n    event_type = \"invoke\"\n    message_class = TranscriptMessage\n</code></pre>"},{"location":"reference/events/join_handler/","title":"join_handler","text":""},{"location":"reference/events/join_handler/#framewise_meet_client.events.join_handler","title":"<code>framewise_meet_client.events.join_handler</code>","text":""},{"location":"reference/events/join_handler/#framewise_meet_client.events.join_handler.JoinHandler","title":"<code>JoinHandler</code>","text":"<p>               Bases: <code>EventHandler[JoinMessage]</code></p> <p>Handler for join events.</p> Source code in <code>framewise_meet_client/events/join_handler.py</code> <pre><code>class JoinHandler(EventHandler[JoinMessage]):\n    \"\"\"Handler for join events.\"\"\"\n\n    event_type = \"on_join\"\n    message_class = JoinMessage\n</code></pre>"},{"location":"reference/events/transcript_handler/","title":"transcript_handler","text":""},{"location":"reference/events/transcript_handler/#framewise_meet_client.events.transcript_handler","title":"<code>framewise_meet_client.events.transcript_handler</code>","text":""},{"location":"reference/events/transcript_handler/#framewise_meet_client.events.transcript_handler.TranscriptHandler","title":"<code>TranscriptHandler</code>","text":"<p>               Bases: <code>EventHandler[TranscriptMessage]</code></p> <p>Handler for transcript events.</p> Source code in <code>framewise_meet_client/events/transcript_handler.py</code> <pre><code>class TranscriptHandler(EventHandler[TranscriptMessage]):\n    \"\"\"Handler for transcript events.\"\"\"\n\n    event_type = \"transcript\"\n    message_class = TranscriptMessage\n</code></pre>"},{"location":"reference/models/","title":"models","text":""},{"location":"reference/models/#framewise_meet_client.models","title":"<code>framewise_meet_client.models</code>","text":""},{"location":"reference/models/#framewise_meet_client.models.MessagePayload","title":"<code>MessagePayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic message payload that can contain any type of content.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MessagePayload(BaseModel):\n    \"\"\"Generic message payload that can contain any type of content.\"\"\"\n    type: str = Field(..., description=\"Message type identifier\")\n    content: Union[JoinEvent, ExitEvent, TranscriptContent, CustomUIElementData, Dict[str, Any]] = Field(\n        ..., description=\"Message content\")\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.JoinMessage","title":"<code>JoinMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a user joining event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class JoinMessage(BaseMessage):\n    \"\"\"Message for a user joining event.\"\"\"\n    message_type: ClassVar[str] = \"on_join\"\n    type: Literal[\"on_join\"] = \"on_join\"\n    content: JoinEvent\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.ExitMessage","title":"<code>ExitMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a user exiting event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class ExitMessage(BaseMessage):\n    \"\"\"Message for a user exiting event.\"\"\"\n    message_type: ClassVar[str] = \"on_exit\"\n    type: Literal[\"on_exit\"] = \"on_exit\"\n    content: ExitEvent\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.TranscriptMessage","title":"<code>TranscriptMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a transcript event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class TranscriptMessage(BaseMessage):\n    \"\"\"Message for a transcript event.\"\"\"\n    message_type: ClassVar[str] = \"transcript\"\n    type: Literal[\"transcript\"] = \"transcript\"\n    content: TranscriptContent = Field(default_factory=TranscriptContent)\n\n    # For backward compatibility\n    transcript: Optional[str] = None\n    is_final: Optional[bool] = None\n\n    @model_validator(mode='after')\n    def _normalize_transcript(self):\n        \"\"\"Support old format where transcript and is_final were at the top level.\"\"\"\n        if self.transcript is not None and not self.content.text:\n            logger.debug(f\"Converting legacy transcript format: '{self.transcript}' to content.text\")\n            self.content.text = self.transcript\n        if self.is_final is not None:\n            logger.debug(f\"Converting legacy is_final format: {self.is_final} to content.is_final\")\n            self.content.is_final = self.is_final\n        return self\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.CustomUIElementMessage","title":"<code>CustomUIElementMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a custom UI element response.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementMessage(BaseMessage):\n    \"\"\"Message for a custom UI element response.\"\"\"\n    message_type: ClassVar[str] = \"custom_ui_element_response\" \n    type: Literal[\"custom_ui_element_response\"] = \"custom_ui_element_response\"\n    content: CustomUIElementData\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.MCQSelectionMessage","title":"<code>MCQSelectionMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for an MCQ selection event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQSelectionMessage(BaseMessage):\n    \"\"\"Message for an MCQ selection event.\"\"\"\n    message_type: ClassVar[str] = \"mcq_selection\"\n    type: Literal[\"mcq_selection\"] = \"mcq_selection\"\n    content: MCQSelectionContent\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.MCQQuestionData","title":"<code>MCQQuestionData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for an MCQ question element.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQQuestionData(BaseModel):\n    \"\"\"Data for an MCQ question element.\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the question\")\n    question: str = Field(..., description=\"The question text\")\n    options: List[str] = Field(..., description=\"List of answer options\")\n    response: Optional[str] = Field(None, description=\"The user's selected response\")\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.TranscriptContent","title":"<code>TranscriptContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of a transcript message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class TranscriptContent(BaseModel):\n    \"\"\"Content of a transcript message.\"\"\"\n    text: str = Field(\"\", description=\"The transcribed text\")\n    is_final: bool = Field(False, description=\"Whether this is a final transcript\")\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.GeneratedTextMessage","title":"<code>GeneratedTextMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for sending generated text.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class GeneratedTextMessage(BaseMessage):\n    \"\"\"Message for sending generated text.\"\"\"\n    message_type: ClassVar[str] = \"generated_text\"\n    type: Literal[\"generated_text\"] = \"generated_text\"\n    content: GeneratedTextContent\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.GeneratedTextContent","title":"<code>GeneratedTextContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of a generated text message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class GeneratedTextContent(BaseModel):\n    \"\"\"Content of a generated text message.\"\"\"\n    text: str = Field(\"\", description=\"The generated text\")\n    is_generation_end: bool = Field(False, description=\"Whether this is the end of generation\")\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.CustomUIElementSendMessage","title":"<code>CustomUIElementSendMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for sending a custom UI element.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementSendMessage(BaseMessage):\n    \"\"\"Message for sending a custom UI element.\"\"\"\n    message_type: ClassVar[str] = \"custom_ui_element\"\n    type: Literal[\"custom_ui_element\"] = \"custom_ui_element\"\n    content: CustomUIElementSendData\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.CustomUIElementSendData","title":"<code>CustomUIElementSendData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for a custom UI element to be sent.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementSendData(BaseModel):\n    \"\"\"Data for a custom UI element to be sent.\"\"\"\n    type: str = Field(..., description=\"Type of UI element\")\n    data: Union[MCQQuestionSendData, Dict[str, Any]] = Field(..., description=\"Element-specific data\")\n</code></pre>"},{"location":"reference/models/#framewise_meet_client.models.MCQQuestionSendData","title":"<code>MCQQuestionSendData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for an MCQ question to be sent.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQQuestionSendData(BaseModel):\n    \"\"\"Data for an MCQ question to be sent.\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the question\")\n    question: str = Field(..., description=\"The question text\")\n    options: List[str] = Field(..., description=\"List of answer options\")\n</code></pre>"},{"location":"reference/models/messages/","title":"messages","text":""},{"location":"reference/models/messages/#framewise_meet_client.models.messages","title":"<code>framewise_meet_client.models.messages</code>","text":""},{"location":"reference/models/messages/#framewise_meet_client.models.messages.BaseMessage","title":"<code>BaseMessage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all message types.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class BaseMessage(BaseModel):\n    \"\"\"Base class for all message types.\"\"\"\n    message_type: ClassVar[str] = \"\"\n\n    def model_post_init(self, __context):\n        \"\"\"Log successful object creation.\"\"\"\n        logger.debug(f\"Created {self.__class__.__name__} object\")\n        return super().model_post_init(__context) if hasattr(super(), 'model_post_init') else None\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.BaseMessage.model_post_init","title":"<code>model_post_init(__context)</code>","text":"<p>Log successful object creation.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>def model_post_init(self, __context):\n    \"\"\"Log successful object creation.\"\"\"\n    logger.debug(f\"Created {self.__class__.__name__} object\")\n    return super().model_post_init(__context) if hasattr(super(), 'model_post_init') else None\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.UserInfo","title":"<code>UserInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about a user in a meeting.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class UserInfo(BaseModel):\n    \"\"\"Information about a user in a meeting.\"\"\"\n    meeting_id: str = Field(..., description=\"The ID of the meeting\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.JoinEvent","title":"<code>JoinEvent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Event data for a user joining a meeting.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class JoinEvent(BaseModel):\n    \"\"\"Event data for a user joining a meeting.\"\"\"\n    user_joined: UserInfo = Field(..., description=\"User joining information\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.ExitEvent","title":"<code>ExitEvent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Event data for a user exiting a meeting.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class ExitEvent(BaseModel):\n    \"\"\"Event data for a user exiting a meeting.\"\"\"\n    user_exited: Optional[Union[UserInfo, str, Dict[str, Any]]] = Field(None, description=\"User exiting information\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.TranscriptContent","title":"<code>TranscriptContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of a transcript message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class TranscriptContent(BaseModel):\n    \"\"\"Content of a transcript message.\"\"\"\n    text: str = Field(\"\", description=\"The transcribed text\")\n    is_final: bool = Field(False, description=\"Whether this is a final transcript\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MCQQuestionData","title":"<code>MCQQuestionData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for an MCQ question element.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQQuestionData(BaseModel):\n    \"\"\"Data for an MCQ question element.\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the question\")\n    question: str = Field(..., description=\"The question text\")\n    options: List[str] = Field(..., description=\"List of answer options\")\n    response: Optional[str] = Field(None, description=\"The user's selected response\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MCQQuestionResponseData","title":"<code>MCQQuestionResponseData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for an MCQ question response.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQQuestionResponseData(BaseModel):\n    \"\"\"Data for an MCQ question response.\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the question\")\n    question: str = Field(..., description=\"The question text\")\n    selectedOption: str = Field(..., description=\"The selected option text\")\n    selectedIndex: int = Field(..., description=\"The selected option index (0-based)\")\n    options: Optional[List[str]] = Field(None, description=\"List of answer options\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.CustomUIElementData","title":"<code>CustomUIElementData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for a custom UI element response.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementData(BaseModel):\n    \"\"\"Data for a custom UI element response.\"\"\"\n    type: str = Field(..., description=\"Type of UI element\")\n    data: Union[MCQQuestionResponseData, Dict[str, Any]] = Field(..., description=\"Element-specific data\")\n\n    @model_validator(mode='after')\n    def validate_data_type(self):\n        \"\"\"Validate that data matches the declared type.\"\"\"\n        return self\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.CustomUIElementData.validate_data_type","title":"<code>validate_data_type()</code>","text":"<p>Validate that data matches the declared type.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>@model_validator(mode='after')\ndef validate_data_type(self):\n    \"\"\"Validate that data matches the declared type.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MessagePayload","title":"<code>MessagePayload</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Generic message payload that can contain any type of content.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MessagePayload(BaseModel):\n    \"\"\"Generic message payload that can contain any type of content.\"\"\"\n    type: str = Field(..., description=\"Message type identifier\")\n    content: Union[JoinEvent, ExitEvent, TranscriptContent, CustomUIElementData, Dict[str, Any]] = Field(\n        ..., description=\"Message content\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.JoinMessage","title":"<code>JoinMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a user joining event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class JoinMessage(BaseMessage):\n    \"\"\"Message for a user joining event.\"\"\"\n    message_type: ClassVar[str] = \"on_join\"\n    type: Literal[\"on_join\"] = \"on_join\"\n    content: JoinEvent\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.ExitMessage","title":"<code>ExitMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a user exiting event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class ExitMessage(BaseMessage):\n    \"\"\"Message for a user exiting event.\"\"\"\n    message_type: ClassVar[str] = \"on_exit\"\n    type: Literal[\"on_exit\"] = \"on_exit\"\n    content: ExitEvent\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.TranscriptMessage","title":"<code>TranscriptMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a transcript event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class TranscriptMessage(BaseMessage):\n    \"\"\"Message for a transcript event.\"\"\"\n    message_type: ClassVar[str] = \"transcript\"\n    type: Literal[\"transcript\"] = \"transcript\"\n    content: TranscriptContent = Field(default_factory=TranscriptContent)\n\n    # For backward compatibility\n    transcript: Optional[str] = None\n    is_final: Optional[bool] = None\n\n    @model_validator(mode='after')\n    def _normalize_transcript(self):\n        \"\"\"Support old format where transcript and is_final were at the top level.\"\"\"\n        if self.transcript is not None and not self.content.text:\n            logger.debug(f\"Converting legacy transcript format: '{self.transcript}' to content.text\")\n            self.content.text = self.transcript\n        if self.is_final is not None:\n            logger.debug(f\"Converting legacy is_final format: {self.is_final} to content.is_final\")\n            self.content.is_final = self.is_final\n        return self\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.CustomUIElementMessage","title":"<code>CustomUIElementMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for a custom UI element response.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementMessage(BaseMessage):\n    \"\"\"Message for a custom UI element response.\"\"\"\n    message_type: ClassVar[str] = \"custom_ui_element_response\" \n    type: Literal[\"custom_ui_element_response\"] = \"custom_ui_element_response\"\n    content: CustomUIElementData\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MCQSelectionContent","title":"<code>MCQSelectionContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of an MCQ selection message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQSelectionContent(BaseModel):\n    \"\"\"Content of an MCQ selection message.\"\"\"\n    selectedOption: str = Field(..., description=\"The selected option text\")\n    selectedIndex: int = Field(..., description=\"The selected option index (0-based)\")\n    question: str = Field(...,description=\"the question name\")\n    id: Optional[str] = Field(None, description=\"ID of the related question\")\n    image_path: Optional[str] = Field(None,description=\"imae_path\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MCQSelectionMessage","title":"<code>MCQSelectionMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for an MCQ selection event.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQSelectionMessage(BaseMessage):\n    \"\"\"Message for an MCQ selection event.\"\"\"\n    message_type: ClassVar[str] = \"mcq_selection\"\n    type: Literal[\"mcq_selection\"] = \"mcq_selection\"\n    content: MCQSelectionContent\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.GeneratedTextContent","title":"<code>GeneratedTextContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of a generated text message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class GeneratedTextContent(BaseModel):\n    \"\"\"Content of a generated text message.\"\"\"\n    text: str = Field(\"\", description=\"The generated text\")\n    is_generation_end: bool = Field(False, description=\"Whether this is the end of generation\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.GeneratedTextMessage","title":"<code>GeneratedTextMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for sending generated text.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class GeneratedTextMessage(BaseMessage):\n    \"\"\"Message for sending generated text.\"\"\"\n    message_type: ClassVar[str] = \"generated_text\"\n    type: Literal[\"generated_text\"] = \"generated_text\"\n    content: GeneratedTextContent\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.MCQQuestionSendData","title":"<code>MCQQuestionSendData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for an MCQ question to be sent.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class MCQQuestionSendData(BaseModel):\n    \"\"\"Data for an MCQ question to be sent.\"\"\"\n    id: str = Field(..., description=\"Unique identifier for the question\")\n    question: str = Field(..., description=\"The question text\")\n    options: List[str] = Field(..., description=\"List of answer options\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.CustomUIElementSendData","title":"<code>CustomUIElementSendData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data for a custom UI element to be sent.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementSendData(BaseModel):\n    \"\"\"Data for a custom UI element to be sent.\"\"\"\n    type: str = Field(..., description=\"Type of UI element\")\n    data: Union[MCQQuestionSendData, Dict[str, Any]] = Field(..., description=\"Element-specific data\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.CustomUIElementSendMessage","title":"<code>CustomUIElementSendMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for sending a custom UI element.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class CustomUIElementSendMessage(BaseMessage):\n    \"\"\"Message for sending a custom UI element.\"\"\"\n    message_type: ClassVar[str] = \"custom_ui_element\"\n    type: Literal[\"custom_ui_element\"] = \"custom_ui_element\"\n    content: CustomUIElementSendData\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.ConnectionRejectedContent","title":"<code>ConnectionRejectedContent</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content of a connection rejected message.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class ConnectionRejectedContent(BaseModel):\n    \"\"\"Content of a connection rejected message.\"\"\"\n    reason: str = Field(\"\", description=\"Reason for connection rejection\")\n    meeting_id: str = Field(\"\", description=\"Meeting ID for which connection was rejected\")\n</code></pre>"},{"location":"reference/models/messages/#framewise_meet_client.models.messages.ConnectionRejectedMessage","title":"<code>ConnectionRejectedMessage</code>","text":"<p>               Bases: <code>BaseMessage</code></p> <p>Message for connection rejection.</p> Source code in <code>framewise_meet_client/models/messages.py</code> <pre><code>class ConnectionRejectedMessage(BaseMessage):\n    \"\"\"Message for connection rejection.\"\"\"\n    message_type: ClassVar[str] = \"connection_rejected\"\n    type: Literal[\"connection_rejected\"] = \"connection_rejected\"\n    content: ConnectionRejectedContent\n</code></pre>"}]}